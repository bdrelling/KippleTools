// Copyright Â© 2024 Brian Drelling. All rights reserved.

import Foundation
import KippleToolsCore

final class FileFormatter {
    // MARK: Shared Instance

    static let shared = FileFormatter()

    // MARK: Constants

    private static let defaultSwiftVersion = "5.6"

    /// A list of files to exclude by default across all projects.
    ///
    /// These are passed manually as arguments because exclusion rules in files passed via the `--config` option are not respected.
    private static let excludedFiles: [String] = [
        // Swift Package Manager
        ".build",
        ".swiftpm",
        "**/Package.swift",
        // CoreData
        "**/*+CoreDataProperties.swift",
        // Vapor Public directory
        "Public",
        // Example files (eg. for use as blog snippets)
        "**/*.example.swift",
        // Autogenerated files (eg. Sourcery, SwiftGen, Apollo, etc.)
        "**/*.autogenerated.swift",
    ]

    // MARK: Initializers

    private init() {}

    // MARK: Methods

    func format(
        configurationFile: String = ".swiftformat",
        swiftVersion: String? = nil,
        targets: [String] = ["."],
        shouldFormatStagedFilesOnly: Bool = false,
        shouldSkipCache: Bool = false,
        isDryRun: Bool = false,
        isQuiet: Bool = false,
        isVerbose: Bool = false,
        logger: VerboseLogging
    ) throws {
        let swiftVersion = swiftVersion ?? Self.defaultSwiftVersion

        // TODO: Allow this to be configured.
        let workingDirectory = FileManager.default.currentDirectoryPath

        // Detect the intended configuration file to use.
        let configurationFilePath: String = try self.pathForConfigurationFile(configurationFile, workingDirectory: workingDirectory)

        let filesToFormat: [String] = try {
            guard targets == ["."] else {
                return targets
            }

            if shouldFormatStagedFilesOnly {
                return try self.stagedFilePaths()
            } else {
                return targets
            }
        }()

        // Log all options and arguments for this command.
        logger.log("------------------------------------------------------------")
        logger.log("DEBUG INFO")
        logger.log("------------------------------------------------------------")
        logger.log("=> Swift Version:        \(swiftVersion)")
        logger.log("=> Working Directory:    \(workingDirectory)")
        logger.log("=> Configuration File:   \(configurationFilePath)")
        logger.log("=> Targets:              \(targets)")
        logger.log("=> Staged Files Only?:   \(shouldFormatStagedFilesOnly)")
        logger.log("=> Skip Cache?:          \(shouldSkipCache)")
        logger.log("=> Dry Run?:             \(isDryRun)")
        logger.log("=> Quiet?:               \(isQuiet)")
        logger.log("=> Verbose?:             \(isVerbose)")

        // Adjust logging of file paths for prettier output depending on count.
        if filesToFormat.count > 1 {
            logger.log("=> Formatted File Paths:")

            for file in filesToFormat {
                logger.log("     - \(file)")
            }
        } else if let firstFile = filesToFormat.first {
            logger.log("=> Formatted File Path:  \(firstFile)")
        } else {
            logger.log("=> Formatted File Paths: ?")
        }

        logger.log("=> Arguments:            \(CommandLine.arguments.dropFirst())")
        logger.log("------------------------------------------------------------")

        // Each set of arguments is an array, which is flattened into a single String array before passing into the Process.
        var arguments: [String] = [
            // First, include all files that should be formatted.
            filesToFormat,
            ["--swiftversion", swiftVersion],
            ["--config", configurationFilePath],
            ["--exclude", Self.excludedFiles.joined(separator: ",")],
        ].flatMap { $0 }

        if shouldSkipCache {
            arguments.append(contentsOf: ["--cache", "ignore"])
        }

        if isDryRun {
            arguments.append("--dryrun")
        }

        if isQuiet {
            arguments.append("--quiet")
        }

        if isVerbose {
            arguments.append("--verbose")

            let command = "$ swift run swiftformat \(arguments.joined(separator: " "))"

            logger.log("=> SwiftFormat Command:")
            logger.log(command)
            logger.log("------------------------------------------------------------")
        }

        guard filesToFormat.count > 0 else {
            logger.log("No files to format.", ignoresVerbose: true)
            return
        }

        let swiftFormat = SwiftFormat()
        swiftFormat.run(in: workingDirectory, arguments: arguments)

        // If we formatted staged files, we need to add them back to the commit.
        // We only do this if we weren't doing a dry run.
        if shouldFormatStagedFilesOnly, !isDryRun {
            try self.addFilesToCommit(files: filesToFormat)
        }
    }

    func pathForConfigurationFile(_ configurationFile: String = ".swiftformat", workingDirectory: String = FileManager.default.currentDirectoryPath) throws -> String {
        // The order of precedence is as follows:
        //   1. Files at an exact path.
        //   2. Files relative to the working directory.
        //   3. Bundled files with an exact matching name.
        //   4. The default bundled file. (only applicable if the configurationFile paramteter matches its default value)
        if FileManager.default.fileExists(atPath: configurationFile) {
            return configurationFile
        } else if FileManager.default.fileExists(atPath: "\(workingDirectory)/\(configurationFile)") {
            return "\(workingDirectory)/\(configurationFile)"
        } else if let path = Bundle.module.path(forResource: configurationFile, ofType: nil) {
            return path
        } else if configurationFile == ".swiftformat", let path = Bundle.module.path(forResource: "default.swiftformat", ofType: nil) {
            return path
        } else {
            // Since config was provided and there is no path or template, return an error.
            throw FormatError.configurationFileNotFound(configurationFile)
        }
    }

    // TODO: Look into references, see if you can optimize?
    // References:
    //   - https://github.com/shibapm/Komondor/blob/3734b0e8b62cc9a59c487eb0796905c441bf9c10/Sources/Komondor/Commands/runner.swift#L65C1-L74C2
    private func stagedFilePaths() throws -> [String] {
        let command = "git diff --diff-filter=d --staged --name-only"
        let output = try Shell.bash(command)

        return output
            // Split on newline.
            .split(separator: "\n")
            // Filter out non-Swift files.
            .filter { $0.hasSuffix(".swift") }
            // Map from String.Subsequence back to String.
            .map(String.init)
    }

    private func addFilesToCommit(files: [String]) throws {
        let commands = files.map { "git add \($0)" }
        let combinedCommand = commands.joined(separator: " && ")

        try Shell.bash(combinedCommand)
    }
}

// MARK: - Supporting Types

private enum FormatError: Error {
    case configurationFileNotDetected
    case configurationFileNotFound(String)
}

extension FormatError: LocalizedError {
    var errorDescription: String? {
        switch self {
        case .configurationFileNotDetected:
            return """
            SwiftFormat configuration file could not be detected.
            Either ensure a .swiftformat file is located in this directory, or pass the file into the command using the --config option.
            """
        case let .configurationFileNotFound(file):
            return "SwiftFormat configuration file '\(file)' could not be found. If you meant to pass it as a file instead, try './\(file)'."
        }
    }
}
