// Copyright Â© 2022 Brian Drelling. All rights reserved.

import ArgumentParser
import Foundation
import KippleToolsCore

// @main
// public struct Kipple: ParsableCommand {
//    public static let configuration: CommandConfiguration = .init(
////        commandName: "kipple",
//        abstract: "A set of core utilities for use with Kipple projects.",
////        usage: nil,
////        discussion: <#T##String#>,
////        version: <#T##String#>,
////        shouldDisplay: <#T##Bool#>,
//        subcommands: [
//            Format.self,
//        ]
////        defaultSubcommand: <#T##ParsableCommand.Type?#>,
////        helpNames: <#T##NameSpecification?#>
//    )
//
////    @Flag(help: "Include a counter with each repetition.")
////    private var includeCounter = false
////
////    @Option(name: .shortAndLong, help: "The number of times to repeat 'phrase'.")
////    private var count: Int?
////
////    @Argument(help: "The phrase to repeat.")
////    private var phrase: String
////
//    public init() {}
////
////    public mutating func run() throws {
////        //exit(CLI.run(in: FileManager.default.currentDirectoryPath).rawValue)
////        print("Yikes!")
//////        let repeatCount = count ?? 2
//////
//////        for i in 1...repeatCount {
//////            if includeCounter {
//////                print("\(i): \(phrase)")
//////            } else {
//////                print(phrase)
//////            }
//////        }
////    }
// }

// swiftformat:options --varattributes prev-line
@main
struct Format: AsyncParsableCommand {
    enum CodingKeys: String, CodingKey {
        case configurationFile
        case isDebugging
        case isDryRun
        case shouldFormatStagedFilesOnly
        case shouldSkipCache
        case swiftVersion
        case targets
    }

    static let configuration: CommandConfiguration = .init(
        commandName: "format",
        abstract: "Formatters Swift files."
    )

    @Option(name: .customLong("config"), help: "The SwiftFormat configuration file path or template to use. (default: \"default\")")
    private var configurationFile: String?

    @Option(name: .long, help: "The Swift version to format.")
    private var swiftVersion: String?

    @Option(name: .long, help: "The list of targets. (default: [\".\"]")
    private var targets: [String] = ["."]

    @Flag(name: .customLong("staged-only"), help: "Whether or not to format staged files only.")
    private var shouldFormatStagedFilesOnly: Bool = false

    @Flag(name: .customLong("skip-cache"), help: "Whether or not to skip SwiftFormat's caching step.")
    private var shouldSkipCache: Bool = false

    @Flag(name: .customLong("debug"), help: "Whether or not to print debugging information.")
    private var isDebugging: Bool = false

    @Flag(name: .customLong("dryrun"), help: "Whether or not to skip the formatting step.")
    private var isDryRun: Bool = false

    static let defaultSwiftVersion = "5.6"

    /// A list of files to exclude by default across all projects.
    ///
    /// These are passed manually as arguments because exclusion rules in files passed via the `--config` option are not respected.
    private let excludedFiles: [String] = [
        // Swift Package Manager
        ".build",
        ".swiftpm",
        "**/Package.swift",
        // CoreData
        "**/*+CoreDataProperties.swift",
        // Vapor Public directory
        "Public",
        // Example files (eg. for use as blog snippets)
        "**/*.example.swift",
        // Autogenerated files (eg. Sourcery, SwiftGen, Apollo, etc.)
        "**/*.autogenerated.swift",
    ]

    mutating func run() async throws {
        let swiftVersion = self.swiftVersion ?? Self.defaultSwiftVersion

        // TODO: Allow this to be configured.
        let workingDirectory = FileManager.default.currentDirectoryPath

        let fileClerk = FileClerk(bundle: .module)

        // Detect the intended configuration file to use.
        // The order of precedence is as follows:
        //   1. Any file argument passed in should be respected first and foremost.
        //   2. Any detected file within the working directory where this is executed.
        //   3. The default templated configuration file.
        let configurationFilePath: String = try {
            if let config = self.configurationFile {
                // A config argument was explicitly passed in, so search for files, then templates
                if FileManager.default.fileExists(atPath: config) {
                    // Evaluate if a file exists at this path. If it does, return it.
                    return config
                } else if let configurationFile = fileClerk.configurationFile(for: .swiftformat, named: config) {
                    // Evaluate if a template exists with this name. If it does, return it.
                    return configurationFile.path
                } else {
                    // Since config was provided and there is no path or template, return an error.
                    throw FormatError.configurationFileNotFound(config)
                }
            } else {
                // No config argument was passed in, so we attempt to detect it.

                // First, we define the default configuration file path, which looks for a .swiftformat file in the working directory.
                let defaultConfigurationFilePath = "\(workingDirectory)/.swiftformat"

                if FileManager.default.fileExists(atPath: defaultConfigurationFilePath) {
                    // There is a .swiftformat file in this directory, so return it as the path.
                    return defaultConfigurationFilePath
                } else if let defaultConfigurationFile = fileClerk.defaultConfigurationFile(for: .swiftformat) {
                    // Finally, we attempt to return the default configuration file from this module.
                    return defaultConfigurationFile.path
                } else {
                    // If no files were ever detected, throw an error.
                    throw FormatError.configurationFileNotDetected
                }
            }
        }()

        let filesToFormat: [String] = try {
            guard self.targets == ["."] else {
                return self.targets
            }

            if self.shouldFormatStagedFilesOnly {
                return try self.stagedFilePaths()
            } else {
                return self.targets
            }
        }()

        guard filesToFormat.count > 0 else {
            throw FormatError.targetFilesNotFound
        }

        if self.isDebugging {
            print("------------------------------------------------------------")
            print("DEBUG INFO")
            print("------------------------------------------------------------")
            print("=> Swift Version:         \(swiftVersion)")
            print("=> Working Directory:     \(workingDirectory)")
            print("=> Configuration File:    \(configurationFilePath)")
            print("=> Targets:               \(self.targets)")
            print("=> Staged Files Only?:    \(self.shouldFormatStagedFilesOnly)")
            print("=> Skip Cache?:           \(self.shouldSkipCache)")
            print("=> Debugging?:            \(self.isDebugging)")
            print("=> Dry Run?:              \(self.isDryRun)")

            // Adjust printing of file paths for prettier output depending on count.
            if filesToFormat.count > 1 {
                print("=> Formatted File Paths:")

                for file in filesToFormat {
                    print("     - \(file)")
                }
            } else if let firstFile = filesToFormat.first {
                print("=> Formatted File Path:   \(firstFile)")
            } else {
                print("=> Formatted File Paths:  ?")
            }

            print("=> Arguments:             \(CommandLine.arguments.dropFirst())")
            print("------------------------------------------------------------")
        }

        // Each set of arguments is an array, which is flattened into a single String array before passing into the Process.
        var arguments: [String] = [
            // First, include all files that should be formatted.
            filesToFormat,
            ["--swiftversion", swiftVersion],
            ["--config", configurationFilePath],
            ["--cache", String(self.shouldSkipCache)],
            ["--exclude", self.excludedFiles.joined(separator: ",")],
        ].flatMap { $0 }

        if self.isDebugging {
            let command = "$ swift run swiftformat \(arguments.joined(separator: " "))"

            print("=> SwiftFormat Command:")
            print(command)
            print("------------------------------------------------------------")
        }

        if self.isDryRun {
            arguments.append("--dryrun")
        }

        let swiftFormat = SwiftFormat()
        try swiftFormat.run(in: workingDirectory, arguments: arguments)

        // If we formatted staged files, we need to add them back to the commit.
        // We only do this if we weren't doing a dry run.
        if self.shouldFormatStagedFilesOnly, !self.isDryRun {
            try self.addFilesToCommit(files: filesToFormat)
        }
    }

    private func stagedFilePaths() throws -> [String] {
        let command = "git diff --diff-filter=d --staged --name-only"
        let output = try ConfiguredProcess.bash(command: command).run()

        return output
            // Split on newline.
            .split(separator: "\n")
            // Filter out non-Swift files.
            .filter { $0.hasSuffix(".swift") }
            // Map from String.Subsequence back to String.
            .map(String.init)
    }

    private func addFilesToCommit(files: [String]) throws {
        let commands = files.map { "git add \($0)" }
        let combinedCommand = commands.joined(separator: " && ")

        try ConfiguredProcess.bash(command: combinedCommand).run()
    }
}
