//
//  File.swift
//  
//
//  Created by Brian Drelling on 7/28/22.
//

import ArgumentParser
import Foundation
import KippleToolsCore
import SwiftFormat

//@main
//public struct Kipple: ParsableCommand {
//    public static let configuration: CommandConfiguration = .init(
////        commandName: "kipple",
//        abstract: "A set of core utilities for use with Kipple projects.",
////        usage: nil,
////        discussion: <#T##String#>,
////        version: <#T##String#>,
////        shouldDisplay: <#T##Bool#>,
//        subcommands: [
//            Format.self,
//        ]
////        defaultSubcommand: <#T##ParsableCommand.Type?#>,
////        helpNames: <#T##NameSpecification?#>
//    )
//
////    @Flag(help: "Include a counter with each repetition.")
////    private var includeCounter = false
////
////    @Option(name: .shortAndLong, help: "The number of times to repeat 'phrase'.")
////    private var count: Int?
////
////    @Argument(help: "The phrase to repeat.")
////    private var phrase: String
////
//    public init() {}
////
////    public mutating func run() throws {
////        //exit(CLI.run(in: FileManager.default.currentDirectoryPath).rawValue)
////        print("Yikes!")
//////        let repeatCount = count ?? 2
//////
//////        for i in 1...repeatCount {
//////            if includeCounter {
//////                print("\(i): \(phrase)")
//////            } else {
//////                print(phrase)
//////            }
//////        }
////    }
//}

@main
struct Format: AsyncParsableCommand {
    enum CodingKeys: String, CodingKey {
        case isDebugging
        case shouldFormatStagedFilesOnly
        case swiftVersion
        case targets
    }
    
    static let configuration: CommandConfiguration = .init(
        commandName: "format",
        abstract: "Formatters Swift files."
    )
    
    @Option(name: .long, help: "The Swift version to format.")
    private var swiftVersion: String?
    
    @Option(name: .long, help: "The list of targets. (default: [\".\"]")
    private var targets: [String] = ["."]
    
    @Flag(name: .customLong("staged-only"), help: "Whether or not to format staged files only. (default: false)")
    private var shouldFormatStagedFilesOnly: Bool = false
    
    @Flag(name: .customLong("debug"), help: "Whether or not to print debugging information. (default: false)")
    private var isDebugging: Bool = false
    
    private let fileManager: FileManager = .default
    
#warning("Detect this instead?")
    static let defaultSwiftVersion = "5.6"
    
    /// A list of files to exclude by default across all projects.
    ///
    /// These are passed manually as arguments because exclusion rules in files passed via the `--config` option are not respected.
    private let excludedFiles: [String] = [
        // Swift Package Manager
        ".build",
        ".swiftpm",
        "**/Package.swift",
        // CoreData
        "**/*+CoreDataProperties.swift",
        // Vapor Public directory
        "Public",
        // Example files (eg. for use as blog snippets)
        "**/*.example.swift",
        // Autogenerated files (eg. Sourcery, SwiftGen, Apollo, etc.)
        "**/*.autogenerated.swift",
    ]
    
    mutating func run() async throws {
        let swiftVersion = self.swiftVersion ?? Self.defaultSwiftVersion

        // Detect the intended configuration file to use.
        // The order of precedence is as follows:
        //   1. Any file argument passed in should be respected first and foremost.
        //   1. Any file template name argument passed in should be respected second.
        //   3. Any detected file within the working directory where this is executed.
        //   4. The first templated configuration file with a given name.
        //   5. The default templated configuration file.
        #warning("DETECT CONFIGURATION FILE PATH TOO!")
        let fileClerk = FileClerk(bundle: .module)
        
        guard let configurationFile = fileClerk.configurationFile(for: .swiftformat, named: "default") else {
            throw FormatError.configurationFileNotFound
        }
//        let configurationFilePath: String = try {
//            if let option = extractor.option(named: "config") {
//                return option
//            }
//
//            if let templateName = extractor.option(named: "config-template") {
//                return try self.templatedConfigurationFilePath(named: templateName, using: fileProvider)
//            }
//
//            let defaultConfigurationFilePath = "\(package.directory)/.swiftformat"
//
//            if self.fileManager.fileExists(atPath: defaultConfigurationFilePath) {
//                return defaultConfigurationFilePath
//            } else {
//                // Return the default template file.
//                return try self.templatedConfigurationFilePath(named: nil, using: fileProvider)
//            }
//        }()

        let filesToFormat: [String] = try {
            guard self.targets.isEmpty else {
                return targets
            }

            if self.shouldFormatStagedFilesOnly {
                return try self.stagedFilePaths()
            }

            return ["."]
        }()

        #warning("GET SWIFTFORMAT EXECUTABLE PATH")
        let executablePath = "" // swiftformat.path.string

        if self.isDebugging {
            print("------------------------------------------------------------")
            print("DEBUG INFO")
            print("------------------------------------------------------------")
            print("=> Executable Path:       \(executablePath)")
            print("=> Swift Version:         \(swiftVersion)")
            print("=> Working Directory:     ???")
            print("=> Configuration File:    \(configurationFile.path)")
            print("=> Debugging?:            \(self.isDebugging)")
            print("=> Staged Files Only?:    \(self.shouldFormatStagedFilesOnly)")
            print("=> Targets:               \(self.targets)")

            // Adjust printing of file paths for prettier output depending on count.
            if filesToFormat.count > 1 {
                print("=> Formatted File Paths:")

                for file in filesToFormat {
                    print("     - \(file)")
                }
            } else if let firstFile = filesToFormat.first {
                print("=> Formatted File Path:   \(firstFile)")
            } else {
                print("=> Formatted File Paths:  ?")
            }

            print("=> Arguments:             \(CommandLine.arguments.dropFirst())")
            print("------------------------------------------------------------")
        }

        // Each set of arguments is an array, which is flattened into a single String array before passing into the Process.
        let arguments: [String] = [
            // First, include all files that should be formatted.
            filesToFormat,
            ["--swiftversion", swiftVersion],
            ["--config", configurationFile.path],
            // SwiftFormat caches outside of the package directory, which is inaccessible to this package, so we cannot cache results.
            // TODO: Investigate alternative directory or system of caching, or open SwiftFormat issue to address?
            ["--cache", "ignore"],
            ["--exclude", self.excludedFiles.joined(separator: ",")],
            CommandLine.arguments,
        ].flatMap { $0 }

        if self.isDebugging {
            let command = "$ swift run swiftformat \(arguments.joined(separator: " "))"

            print("=> SwiftFormat Command:")
            print(command)
            print("------------------------------------------------------------")
        }
        
        return
        
        try self.runSwiftFormat(
            executablePath: executablePath,
            arguments: arguments
        )
        
        // If we formatted staged files, we need to add them back to the commit.
        if self.shouldFormatStagedFilesOnly {
            try self.addFilesToCommit(files: filesToFormat)
        }
    }
    
    private func runSwiftFormat(executablePath: String, arguments: [String]) throws {
        try ConfiguredProcess(
            executablePath: executablePath,
            arguments: arguments
        ).run()
    }

    private func stagedFilePaths() throws -> [String] {
        let command = "git diff --diff-filter=d --staged --name-only"
        let output = try ConfiguredProcess.bash(command: command).run()

        return output
            // Split on newline.
            .split(separator: "\n")
            // Filter out non-Swift files.
            .filter { $0.hasSuffix(".swift") }
            // Map from String.Subsequence back to String.
            .map(String.init)
    }

    private func addFilesToCommit(files: [String]) throws {
        let commands = files.map { "git add \($0)" }
        let combinedCommand = commands.joined(separator: " && ")

        try ConfiguredProcess.bash(command: combinedCommand).run()
    }
}

// MARK: - Supporting Types

enum FormatError: Error {
    case configurationFileNotFound
}
