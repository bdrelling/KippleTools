// Copyright Â© 2022 Brian Drelling. All rights reserved.

import Foundation
import KippleToolsCore

public final class FileFormatter {
    // MARK: - Constants

    private static let defaultSwiftVersion = "5.6"

    /// A list of files to exclude by default across all projects.
    ///
    /// These are passed manually as arguments because exclusion rules in files passed via the `--config` option are not respected.
    private static let excludedFiles: [String] = [
        // Swift Package Manager
        ".build",
        ".swiftpm",
        "**/Package.swift",
        // CoreData
        "**/*+CoreDataProperties.swift",
        // Vapor Public directory
        "Public",
        // Example files (eg. for use as blog snippets)
        "**/*.example.swift",
        // Autogenerated files (eg. Sourcery, SwiftGen, Apollo, etc.)
        "**/*.autogenerated.swift",
    ]

    // MARK: - Initializers

    private init() {}

    // MARK: - Methods

    public static func format(
        configurationFile: String? = nil,
        swiftVersion: String? = nil,
        targets: [String] = ["."],
        shouldFormatStagedFilesOnly: Bool = false,
        shouldSkipCache: Bool = false,
        isDebugging: Bool = false,
        isDryRun: Bool = false,
        isQuiet: Bool = false
    ) throws {
        let swiftVersion = swiftVersion ?? Self.defaultSwiftVersion

        // TODO: Allow this to be configured.
        let workingDirectory = FileManager.default.currentDirectoryPath

        let fileClerk = FileClerk(bundle: .module)

        // Detect the intended configuration file to use.
        // The order of precedence is as follows:
        //   1. Any file argument passed in should be respected first and foremost.
        //   2. Any detected file within the working directory where this is executed.
        //   3. The default templated configuration file.
        let configurationFilePath: String = try {
            if let config = configurationFile {
                // A config argument was explicitly passed in, so search for files, then templates
                if FileManager.default.fileExists(atPath: config) {
                    // Evaluate if a file exists at this path. If it does, return it.
                    return config
                } else if let configurationFile = fileClerk.configurationFile(for: .swiftformat, named: config) {
                    // Evaluate if a template exists with this name. If it does, return it.
                    return configurationFile.path
                } else {
                    // Since config was provided and there is no path or template, return an error.
                    throw FormatError.configurationFileNotFound(config)
                }
            } else {
                // No config argument was passed in, so we attempt to detect it.

                // First, we define the default configuration file path, which looks for a .swiftformat file in the working directory.
                let defaultConfigurationFilePath = "\(workingDirectory)/.swiftformat"

                if FileManager.default.fileExists(atPath: defaultConfigurationFilePath) {
                    // There is a .swiftformat file in this directory, so return it as the path.
                    return defaultConfigurationFilePath
                } else if let defaultConfigurationFile = fileClerk.defaultConfigurationFile(for: .swiftformat) {
                    // Finally, we attempt to return the default configuration file from this module.
                    return defaultConfigurationFile.path
                } else {
                    // If no files were ever detected, throw an error.
                    throw FormatError.configurationFileNotDetected
                }
            }
        }()

        let filesToFormat: [String] = try {
            guard targets == ["."] else {
                return targets
            }

            if shouldFormatStagedFilesOnly {
                return try self.stagedFilePaths()
            } else {
                return targets
            }
        }()

        if isDebugging {
            print("------------------------------------------------------------")
            print("DEBUG INFO")
            print("------------------------------------------------------------")
            print("=> Swift Version:         \(swiftVersion)")
            print("=> Working Directory:     \(workingDirectory)")
            print("=> Configuration File:    \(configurationFilePath)")
            print("=> Targets:               \(targets)")
            print("=> Staged Files Only?:    \(shouldFormatStagedFilesOnly)")
            print("=> Skip Cache?:           \(shouldSkipCache)")
            print("=> Debugging?:            \(isDebugging)")
            print("=> Dry Run?:              \(isDryRun)")

            // Adjust printing of file paths for prettier output depending on count.
            if filesToFormat.count > 1 {
                print("=> Formatted File Paths:")

                for file in filesToFormat {
                    print("     - \(file)")
                }
            } else if let firstFile = filesToFormat.first {
                print("=> Formatted File Path:   \(firstFile)")
            } else {
                print("=> Formatted File Paths:  ?")
            }

            print("=> Arguments:             \(CommandLine.arguments.dropFirst())")
            print("------------------------------------------------------------")
        }

        // Each set of arguments is an array, which is flattened into a single String array before passing into the Process.
        var arguments: [String] = [
            // First, include all files that should be formatted.
            filesToFormat,
            ["--swiftversion", swiftVersion],
            ["--config", configurationFilePath],
            ["--exclude", self.excludedFiles.joined(separator: ",")],
        ].flatMap { $0 }

        if shouldSkipCache {
            arguments.append(contentsOf: ["--cache", "ignore"])
        }

        if isDryRun {
            arguments.append("--dryrun")
        }

        if isQuiet {
            arguments.append("--quiet")
        }

        if isDebugging {
            let command = "$ swift run swiftformat \(arguments.joined(separator: " "))"

            print("=> SwiftFormat Command:")
            print(command)
            print("------------------------------------------------------------")
        }

        guard filesToFormat.count > 0 else {
            print("No files to format. Exiting.")
            return
        }

        let swiftFormat = SwiftFormat()
        swiftFormat.run(in: workingDirectory, arguments: arguments)

        // If we formatted staged files, we need to add them back to the commit.
        // We only do this if we weren't doing a dry run.
        if shouldFormatStagedFilesOnly, !isDryRun {
            try self.addFilesToCommit(files: filesToFormat)
        }
    }

    private static func stagedFilePaths() throws -> [String] {
        let command = "git diff --diff-filter=d --staged --name-only"
        let output = try ConfiguredProcess.bash(command: command).run()

        return output
            // Split on newline.
            .split(separator: "\n")
            // Filter out non-Swift files.
            .filter { $0.hasSuffix(".swift") }
            // Map from String.Subsequence back to String.
            .map(String.init)
    }

    private static func addFilesToCommit(files: [String]) throws {
        let commands = files.map { "git add \($0)" }
        let combinedCommand = commands.joined(separator: " && ")

        try ConfiguredProcess.bash(command: combinedCommand).run()
    }
}
